- **Introduction**
    - You might have noticed that contracts signed between entities or individuals, wet contracts, do not convert into smart contracts easily. In fact, with the strict rules governing how smart contracts function, it's not even clear this is feasible in general, or even desirable (!!). Do parties to a contract usually want the terms to be excecuted unconditionally and without delay? Often the answer is an emphatic "No!"
    - Send Protocol is a generalized framework for contracts to enter the blockchain (or indeed digital) space that takes an orthogonal approach to the intuitive one focused on codifying terms and conditions.
    - Context
        - Our traditional mental model for digitizing agreements looks like cloud application that stores business data and provides business rules to govern a business relationship. To an extent this is correct, since business rules can be programmed into a business application and users can get value out of it. Interestingly though, business applications tend to get very complex very quickly, and they never seem to cover all the edge cases requiring extensive exception handling via human intervention and sometimes legal interpretation. Something always seems to be missing.
        - When we learn that blockchains are a source of truth and execute business rules using things called "smart contracts," we intuit that the cloud application model might somehow translate or bridge to blockchains and create opportunities to add more value by adding contractual relationships into the mix. The question we must then answer is, "how can smart contracts put wet contracts on rails?"
        - Although technically it should be possible to codify business terms or processes on a blockchain the space and performance limitations of blockchains make it obvious that little value can be gained this way, if any at all. In fact, transferring the cloud application model to the blockchain yields a net negative value in most cases. Is there any value there at all then?
        - Some existing approaches try to capitalize on the fact that blockchains act as a state machine and records can remain distributed among many systems. In this model the blockchain would act as a __new kind of constraint__ that can help to synchronise these systems with each other without relying on a single database, such as a cloud application. To an extent this seems like a plausible future, but it does not tell us what kind of functionality the blockchain would hold, other than some "state" variable, which although useful seems to lack the punch of a breakthrough. For now.
        - One such constraint-oriented approach to apply smart contracts to transactions is EY's Baseline [https://docs.baseline-protocol.org/] Protocol. Baseline works by setting up a workgroup of companies that wish to synchronise records between their databases and build workflows and use the Ethereum blockchain as the state machine reference to determine, which version of a record is the latest. Another approach is Corda's Flows that encode business rules and use a notary chain to record compliant changes in the state of data. While interesting concepts, it is not  immediately obvious how these concepts generate the kind of leaps in value that we are used to seeing with disruptive innovation. Another approach is Centrifuge, which is a financing platform onto which invoices need to be onboarded to become eligible for funding. Although the model uses pools for providing capital, harnessing the ability of the crypto space to focus funding in pools, it still relies on a cloud-like model for onboarding and managing the invoices.
        - The successes of cryptocurrencies, then ICOs, and then DeFi, seems to suggest something wholly different. Cryptocurrencies, ERC20 tokens, and DeFi platforms are based on freeform and permissionless primitives. It seems that what blockchains provide is not so much a new kind of constraint, but a __new kind of arbitrary freedom__. And so the question becomes, "how can smart contracts give wet contracts freedom?" This is a much more fun question to ponder.
        - And so, the purpose of Send Protocol is to give agreements freedom allowing them to be traded or securitised across many platforms, or even peer to peer, while letting the user add workflows, business rules, and data on top __if they so choose__.
        - In this article I suggest the appropriate elementary concepts that allow putting wet contracts on-chain into permissionless structures that lend themselves to cross-platform composability, a key feature of DeFi and the reason Send is a _protocol_.
- Concept
    - First things first, let's clear the mental space of preconceptions. Wet contract terms and conditions are ambiguous, amorphous, dynamic, and often flexible. They do not lend themselves to easy encoding into smart contract rules, so let's forget about them for now and instead focus on what can be encoded.
    - All business arrangements rely on agreeing to rights and obligations. This is done with the use of legal documents, like contracts, bills of lading, invoices, etc. As transactions are made, contracts are executed, business processes followed, rights and obligations created, transferred, changed, or fulfilled/destroyed.
    - Send Protocol provides primitives that allow formulation of wet contract _endpoints_ in the form of __rights__ and __obligations__, and defines a __finite set of rules__ that allow transitions for these endpoints that are generalized across all wet contract types at the same time these endpoints are a precise reflection of existing legal practice, which makes them compatible with existing wet contracts.
    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSnailpace%2FURfrSGMA-R.png?alt=media&token=4390e0a8-ff96-4cc1-bbfe-3aaf82e2b119)
    - Send Protocol contract __endpoints__ are NFTs that can be held in a wallet and transferred according to rule templates that correspond to the closed set of legal actions that are possible on any wet contract: __Assignment, Novation, Renegotiation, and Termination__.
    - The four types of action on a contract operate on tokens that represent __rights__ and __obligations__. A Rights Token (RT) represents rights that can change hands (ex. via assignment), while an Obligation Token (OT) represents an obligation that can change hands (ex. via novation). Rights and obligations always exist in linked pairs.
    - In effect, Send Protocol provides a foundational framework for establishing verifiable contractual relationships that are manifested as transferrable __rights__ and __obligations__. Because the operations on these tokens form a closed set, Send can parameterize __any agreement whatsoever__.
    - The Send Protocol framework tokenises contracts using the following primitive concepts. These concepts caputre and exhaust the kinds of operations that are permissible on any contract.
        - 1. Assignment
            - Idea: Rights that are defined in a contract can be unilaterally assigned by the holder of those rights. An assignment does not require the permission of the obligated party.
            - Consequence: Rights Tokens are held in a wallet and can be transferred to another wallet unilaterally. The Rights Token is tied to its corresponding Obligation Token, which remains in the same place after a Rights Token has been transferred. Rithts token assignment might be limited by the parties in the legal terms, but such a limitation is left to the user to define, if they wish.
            - DeFi angle: The Rights Token is an asset-backed NFT and may directly be used in DeFi, as it will act like any other NFT. This might mean the RT can represent the right to receive royalties in a copyright agreement.
        - 2. Novation
            - Idea: Obligations that are defined in a contract require a novation to change the obligated party. A novation requires the agreement of the rights holder and the obligated party, as there is an implied risk associated with the transfer as an obligation (like debt) shifts from one party to another. A novation changes the parties to an agreement, but not the terms.
            - Consequence: Obligation Tokens can be held in a wallet, but cannot be transferred unilaterally. In practice, a transfer must be initiated by the Obligation Token holder wallet and authorized by the Rights Token holder wallet.
            - DeFi: The Obligation Token requires more robust functionality to integrate into DeFi, but represents the debtor side of an agreement. For example a borrower on a mortgage must remain fixed for the rating of the mortgage to remain valid and selling a mortgaged house will require a reevaluation of the credit risk to which the creditor must agree.
        - 3. Renegotiation of Terms
            - Idea: At any time the parties to a contract may renegotiate the terms and all sides need to agree to renegotiate.
            - Consequence: The parties to a wet contract jointly hold the Terms Token, which is an NFT that represents a wet contract document, which may or may not have structure in code. Terms in code are left up to the user to define and are not subject to Send Protol's definition.
        - 4. Termination
            - Idea: A contract may be terminated once all the rights that belong to it are satisfied. The satisfaction of rights may be either:
                - a unilateral decision by the rights holder, or
                - satisfaction of an obligation, if such a rule has been scripted (ex. payment of a specified value is made by the obligor).
            - In effect, termination occurs when all the token pairs associated with a transactions are destroyed.
    - The terms of the contract can be represented by a document whose hash is the Terms NFT that is the parent of the OT/RT pairs in the agreement. The document itself represents the specific terms and conditions that govern OT/RT pairs and may be updated (substituted with a new one) via renegotiation of terms. The precise terms and conditions of the contract remain outside the scope of Send Protocol, and that is its strength. Ts&Cs are ambiguous for most contracts and the task of translating them to smart contract automations is left to the protocol's users, who are experts in their specific use cases.
- Contract Structure [WiP]
    - Users of Send Protocol decide how many OTs and RTs pairs exist and define them at contract instantiation (signing). The RTs and OTs then are subject to the rules of Assignment, Novation, Renegotiation, and Termination. Because each transaction means that an __offer__ of service or product is rendered for a __consideration,__ there should be __two OT/RT pairs__.
        - The first OT/RT pair will represent the two endpoints of the __offer__, i.e. the obligation (OT) to render a service or product and the right (RT) to receive it. This pair might be represented by an _order_ containing a statement of work or product specification.
        - The second OT/RT pair will represent the __consideration__, i.e. the obligation (OT) to pay and a right (RT) to receive the payment. This pair might be represented by an __invoice__ that contains the details of the buyer and seller, the amount, and payment terms.
    - Each RT has a corresponding OT and the terms of a contract determine, how many RT/OT pairs there are. There may, for example, be several tranches to a deal, or a framework agreement might allow for a continuous stream of orders issued against general terms and conditions. In the base case, only two pairs need to be generated, but the number of such reciprocal pairs in practice is only limited by the terms and conditions of the governing contract (which is outside of the scope of Send to understand).
    - The users of the protocol create the token pairs during contract initiation.
    - During initiation of a Send Protocol relationship the following elements are created:
        - A document that records the terms and conditions of the arrangement is hashed and the contract hash is created. No sophisticated support for document management is planned at this time except to allow the document hash to be replaced by agreement of both parties.
        - For each right-obligation pair that the parties want to tokenise two NFTs are created. These NFTs are hashes to a term that describes the right and obligation. The Rights Token is placed in the rights holder's wallet, and the Obligation Token is placed in the obligated party's wallet. 
- Contract Lifecycle
    - Overview
        - A contract goes through three phases during its lifetime:
            - Initiation - During this phase all ROT pairs are defined and any relationships between them also established.
            - Period in force - During the contract period in force, the obligations may be realized and rights may become invoked and satisfied.
            - Termination - Once all Rights Tokens associated with a contract are satisfied or destroyed, the contract is considered terminated.
        - Realization of obligations or rights, like payments, may be scripted in smart contract code that is external to the Send protocol. The goal of the scripts are to serve as an adjudicator on the satisfaction of obligations or rights. The more such scripted adjudicators, the more automated the contract lifecycle becomes. However, it is perfectly possible to have a Send Protocol contract without scripted actions, where all obligation rights or transfers are handled manually by wallet owners.
    - Initiation process
        - Setup of a wet contract on Send starts with choosing what the tokens should represent. This means that the sides of the contract must examine the terms and decide, which endpoints they would like to tokenise.
        - Any business transaction involves the exchange of a product or service for a consideration that goes in the opposite direction. The transfer of a product is represented by one pair of RO tokens, while the consideration is represented by another RO pair.
        - Transactions may involve multiple products, services, tranches, time periods, or phases. Each such discrete unit should correspond to a consideration going the other way. The consideration could be in cash or in kind, but for the purpose of this discussion we will use cash.
        - The sides must choose discrete product or service units to tokenise. For each unit a RT and an OT should be created. One side receives the RT and the other the matching OT. Each pair are inextricably linked.
        - The RT and the OT must also be correctly parametrised, so that they are subject to to the Send rules. By default Send allows the RT to be transferred unilaterally by the holding wallet, while the OT requires the transaction to be signed by both wallets holding the pair.
        - To begin with each RT pair receives the inactive status. This is to signify, when the obligation becomes due. By default, the product/service pair should be activated to initiate the transaction, while the consideration/payment pair should remain inactive. 
        - During process initiation the parties may connect OT to an oracle that will determine, if the OT has been realised.
        - The parties might choose to automate approval of the OT transfer using the Send API. 
        - Finally, a RO pair needs a set of terms and conditions to which the parties have agreed; the contract itself. To this effect the parties submit an NFT hash of a document that represents the terms and conditions that bind them. This NFT is held by both parties' wallets and remains in force until all RO pairs are destroyed. To aid interpretation, the contract should explicitly name the endpoints that are tokenised in RO pairs.
        - A contract NFT may be updated by both sides to the hash of a new agreement.
        - The end result of the initiation of a Send agreement is at least the following set:
            - An RO pair representing the Obligation to render a service or product coupled with the Right to receive it.
            - An RO pair representing the Obligation to pay for the rendered service or product and the Right to be paid.
            - The Contract terms that govern the above RO pairs.
    - Period in force
        - While the sides of the agreement conduct the transaction the RO pairs can have state to signal the state of the transaction. This idea is not yet developed.
    - Termination
        - There are two ways of satisfying a RO pair. Either the RT is destroyed, or the OT is destroyed. Either way, both tokens are annihilated.
        - Calls to the destroy function of each token in the RT pair may be written up in a smart contract, so that once an obligation is realised its OT destroy function is called. 
        - The most basic kind of automation that should be provided by Send protocol is the consideration (payment), since it can be native to the chain. To realise the consideration the OT holding wallet must transfer a defined token amount to the RT holder by calling the Send Consideration function with the required amount.
- Consider the following setup for a normal invoiced sale [WiP do not read]
    - Discussion
        - An invoice is a tricky concept, because it isn't a contract in itself and is a document issued usually for tax purposes or to document a payment. It therefore naturally is represented by the receiv
    - Wallets (Identities)
        - Buyer
        - Seller
        - Document content
            - Invoice data object - The object is stored entirely off-chain and is readable to the parties. It may be a PDF with a scan of a physical document and contains sufficient information for the parties to make their decisions.
            - The invoice may contain a link to the contract on which it is based. This contract will also be a document with its own rights tokens.
    - Tokens
        - Receivable - (Rights token)
            - Defined by who receives the payment for the invoice. Through holding the Receivable token, the seller has the right to mark the receivable as completed once the payment has been made. Initially payments may not be made on-chain and so this could be a unilateral operation by the owner or rights to change status can be handled by a payment processor that is trusted by the owner.
            - The Seller may choose to sell the Receivable to another party, in which case they __Send__ the party the invoice and the Receivable token. Legally, this is an __Assignment__.
        - Liability - (Obligation token)
            - The liability is the Buyer's obligation to pay the invoice. The Buyer's liability cannot be unilaterally transferred by the Buyer. It has to be agreed to by the owner of the receivable. Transfer of this token is therefore legally a __Novation__.
        - Document token
            - The invoice 
