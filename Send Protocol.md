- **Introduction**
    - You might have noticed that contracts signed between entities or individuals, wet contracts, do not convert into smart contracts easily. In fact, with the strict rules governing how smart contracts function, it's not even clear this is feasible in general, or even desirable (!!). Do parties to a contract usually want the terms to be excecuted unconditionally and without delay? Often the answer is an emphatic "No!"
    - Send Protocol is a generalized framework for contracts to enter the blockchain (or indeed digital) space that takes an orthogonal approach to the intuitive one focused on codifying terms and conditions.
    - Context
        - Our traditional mental model for digitizing agreements looks like a cloud application that stores business data and provides business rules to govern a business relationship. To an extent this is correct, since business rules can be programmed into a business application and users can get value out of it. Interestingly though, business applications tend to get very complex very quickly, and they never seem to cover all the edge cases requiring extensive exception handling via human intervention and sometimes legal interpretation. Something always seems to be missing.
        - When we learn that blockchains are a source of truth and execute business rules using things called "smart contracts," we intuit that the cloud application model might somehow translate or bridge to blockchains and create opportunities to add more value by adding contractual relationships into the mix. The question we are then tempted to answer is, "how can smart contracts put wet contracts on rails?"
        - Although technically it should be possible to codify business terms or processes on a blockchain (or even off of it) the space and performance limitations of blockchains and the limitations of business application platforms make it obvious that little additional value can be gained this way, if any at all. In fact, transferring the cloud application model to the blockchain yields a net negative value in most cases. Is there any value there at all then?
        - Some existing approaches try to capitalize on the fact that blockchains act as a state machine and records can remain distributed among many systems. In this model the blockchain would act as a __new kind of constraint__ that can help to synchronise these systems with each other without relying on a single database, such as a cloud application. To an extent this seems like part of a plausible future, but it does not tell us what kind of functionality the blockchain would hold, other than some "state" variable, which although useful seems to lack the punch of a breakthrough. For now.
        - One such constraint-oriented approach to apply smart contracts to transactions is EY's Baseline [https://docs.baseline-protocol.org/] Protocol. Baseline works by setting up a workgroup of companies that wish to synchronise records between their databases and build workflows and use the Ethereum blockchain as the state machine reference to determine, which version of a record is the latest. Another approach is Corda's Flows [https://docs.corda.net/docs/corda-os/4.7/key-concepts-flows.html] that encode business rules and use a notary chain to record compliant changes in the state of data. While interesting concepts, it is not  immediately obvious how these concepts generate the kind of leaps in value that we are used to seeing with disruptive innovation. Another approach is Centrifuge [https://centrifuge.io/], which is a financing platform onto which invoices need to be onboarded to become eligible for funding. Although the model uses DeFi pools for providing capital, it still relies on a cloud-like model for onboarding and managing the assets. A user must be onboarded to Centrifuge to use the platform and so DeFi-like peert-to-peer composability remains elusive.
        - The successes of cryptocurrencies, then ICOs, and then DeFi, seems to suggest something wholly different. Cryptocurrencies, ERC20 tokens, and DeFi platforms are based on freeform and permissionless primitives. It seems that what blockchains provide is not so much a new kind of constraint, but a __new kind of arbitrary freedom__. And so the question becomes, "how can smart contracts give wet contracts freedom?" This is a much more fun question to ponder.
        - And so, the purpose of Send Protocol is to give agreements freedom allowing them to be traded or securitised across many platforms, or even peer to peer, while letting the user add workflows, business rules, and data on top __if they so choose__.
        - In this article I suggest the appropriate elementary concepts that allow putting wet contracts on-chain into permissionless structures that lend themselves to cross-platform composability, a key feature of DeFi and the reason Send is a __protocol__.
- Concept
    - First things first, let's clear the mental space of preconceptions. Wet contract terms and conditions are ambiguous, amorphous, dynamic, and often flexible. They do not lend themselves to easy encoding into smart contract rules, so let's forget about them for now and instead focus on what can be encoded.
    - All business arrangements rely on agreeing to rights and obligations. This is done with the use of legal documents, like contracts, bills of lading, invoices, etc. As transactions are made, contracts are executed, business processes followed, rights and obligations created, transferred, changed, or fulfilled/destroyed.
    - Send Protocol provides primitives that allow formulation of wet contract __endpoints__ in the form of __rights__ and __obligations__, and defines a __finite set of rules__ that allow transitions for these endpoints that are generalized across all wet contract types at the same time these endpoints are a precise reflection of existing legal practice, which makes them compatible with existing wet contracts.
    - ![](https://firebasestorage.googleapis.com/v0/b/firescript-577a2.appspot.com/o/imgs%2Fapp%2FSnailpace%2FURfrSGMA-R.png?alt=media&token=4390e0a8-ff96-4cc1-bbfe-3aaf82e2b119)
    - Send Protocol contract __endpoints__ are NFTs that can be held in a wallet and transferred according to rule templates that correspond to the closed set of legal actions that are possible on any wet contract: __Assignment, Novation, Renegotiation, and Termination__.
    - The four types of action on a contract operate on tokens that represent __rights__ and __obligations__. A Rights Token (RT) represents rights that can change hands (ex. via assignment), while an Obligation Token (OT) represents an obligation that can change hands (ex. via novation). Rights and obligations always exist in linked pairs.
    - In effect, Send Protocol provides a foundational framework for establishing verifiable contractual relationships that are manifested as transferrable __rights__ and __obligations__. Because the operations on these tokens form a closed set, Send can parameterize __any agreement whatsoever__.
    - The Send Protocol framework tokenises contracts using the following primitive concepts. These concepts caputre and exhaust the kinds of operations that are permissible on any contract.
        - 1. Assignment
            - Idea: Rights that are defined in a contract can be unilaterally assigned by the holder of those rights. An assignment does not require the permission of the obligated party.
            - Consequence: Rights Tokens are held in a wallet and can be transferred to another wallet unilaterally. The Rights Token is tied to its corresponding Obligation Token, which remains in the same place after a Rights Token has been transferred. Rithts token assignment might be limited by the parties in the legal terms, but such a limitation is left to the user to define, if they wish.
            - DeFi angle: The Rights Token is an asset-backed NFT and may directly be used in DeFi, as it will act like any other NFT. This might mean the RT can represent the right to receive royalties in a copyright agreement.
        - 2. Novation
            - Idea: Obligations that are defined in a contract require a novation to change the obligated party. A novation requires the agreement of the rights holder and the obligated party, as there is an implied risk associated with the transfer as an obligation (like debt) shifts from one party to another. A novation changes the parties to an agreement, but not the terms.
            - Consequence: Obligation Tokens can be held in a wallet, but cannot be transferred unilaterally. In practice, a transfer must be initiated by the Obligation Token holder wallet and authorized by the Rights Token holder wallet.
            - DeFi angle: The Obligation Token requires more robust functionality to integrate into DeFi, but represents the debtor side of an agreement. For example a borrower on a mortgage must remain fixed for the rating of the mortgage to remain valid and selling a mortgaged house will require a reevaluation of the credit risk to which the creditor must agree.
        - 3. Renegotiation of Terms
            - Idea: At any time the parties to a contract may renegotiate the terms and all sides need to agree to renegotiate.
            - Consequence: The parties to a wet contract jointly hold the Terms Token, which is an NFT that represents a wet contract document, which may or may not have structure in code. Terms in code are left up to the user to define and are not subject to Send Protol's definition.
            - DeFi angle: A renegotiation is an event that should trigger a risk reassessment. If a DeFi protocol operates on this risk rating, it would need to respond to such an event in a way that the protocol users find useful.
        - 4. Termination
            - Idea: A contract may be terminated once all the rights that belong to it are satisfied. The satisfaction of rights may be either:
                - a unilateral decision by the rights holder, or
                - satisfaction of an obligation, if such a rule has been scripted (ex. payment of a specified value is made by the obligor).
            - Consequence: In effect, termination occurs when all the token pairs associated with a transactions are destroyed with agreement from all token owners.
            - DeFi Angle: The DeFi angle here is that any obligations are settled to the satisfaction of the rights holders and the transaction is viewed as settled.
- What about other contract terms and conditions?
    - There are also contract-specific terms and conditions that parties agree to, and these depend on both the industry and the specific deal. They are the most difficult to automate and many are not easily subjected to any kind of automation. Send Protocol 'throws' this complexity up to the user, who may or may not choose to implement it above the platform as either additional conditions or triggers on token transfer, or to invoke token transfer as a result of scripted events.
    - The specific terms of the contract can be represented by a document, or other data object, whose hash is the Terms NFT that is the parent of the OT/RT pairs in the agreement. The document itself represents the specific terms and conditions that govern OT/RT pairs and may be updated (substituted with a new one) via renegotiation of terms. Basic Send Protocol assignment and novation rules should be viewed as integral to these specific terms and the terms must operate within the bounds of Send rules. *The fact that precise terms and conditions of the contract remain outside the scope of Send Protocol is its strength*.
- Send Contract Structure
    - Users of Send Protocol decide how many OTs and RTs pairs exist and define them at contract instantiation (signing). The RTs and OTs then are subject to the rules of Assignment, Novation, Renegotiation, and Termination. Because each transaction means that an __offer__ of service or product is rendered for a __consideration,__ there should be __two OT/RT pairs__.
        - The first OT/RT pair will represent the two endpoints of the __offer__, i.e. the obligation (OT) to render a service or product and the right (RT) to receive it. This pair might be represented by an __order__ containing a statement of work or product specification.
        - The second OT/RT pair will represent the __consideration__, i.e. the obligation (OT) to pay and a right (RT) to receive the payment. This pair might be represented by an __invoice__ that contains the details of the buyer and seller, the amount, and payment terms.
    - Each RT has a corresponding OT and the terms of a contract determine how many RT/OT pairs there are. There may, for example, be several tranches to a deal, or a framework agreement might allow for a continuous stream of orders issued against general terms and conditions. Consequently, in the base case only two RT/OT pairs need to be generated, but the number of such reciprocal pairs in practice is only limited by the terms and conditions of the governing contract (which is outside of the scope of Send to understand). It is only the role of Send to govern (and offer an programming interface to) the terms under which the tokens may be transferred.
    - During initiation of a Send Protocol relationship the following elements are created:
        - A document that records the terms and conditions of the arrangement is hashed and the contract hash is created. No sophisticated support for document management is envisionede at this time except to allow the document hash to be replaced by agreement of both parties.
        - For each right-obligation pair that the parties want to tokenise two NFTs are created. These NFTs are hashes to a term (placeholder) that describes the right and obligation. The Rights Token is placed in the rights holder's wallet, and the Obligation Token is placed in the obligated party's wallet. Specific terms and conditions of the contract between the parties may and should name and refer to these tokens, where relevant to crystallize Sends impact on the relationship.
- Contract Lifecycle
    - Overview
        - A contract goes through three phases during its lifetime:
            - Initiation - During this phase all RT/OT pairs are defined and any relationships between them also established.
            - Performance - During the contract period in force, the obligations may be realized and rights may become invoked and satisfied. In each such case, either an automatic rule is executed (ex. on payment of a specific amount), or the RT holder decides whether the RT/OT pair has been satisfied and may be destroyed.
            - Termination - Once all Rights Tokens associated with a contract are satisfied and/or destroyed, the contract is considered terminated.
        - Realization of obligations or rights, like payments, may be scripted in smart contract code that is external to the Send protocol. The goal of the scripts are to serve as an adjudicator on the satisfaction of obligations or rights. The more such scripted adjudicators, the more automated the contract lifecycle becomes. However, it is perfectly possible to have a Send Protocol contract without scripted actions, where all obligation rights or transfers are handled manually by wallet owners, and where RT owners make unilateral calls regarding satisfaction of terms.
    - Initiation process
        - Setup of a wet contract on Send starts with choosing what the tokens should represent. This means that the sides of the contract must examine the terms and decide, which endpoints they would like to tokenise.
        - Any business transaction involves the exchange of a product or service for a consideration that goes in the opposite direction. The transfer of a product is represented by one pair of RO tokens, while the consideration is represented by another RO pair.
        - Transactions may involve multiple products, services, tranches, time periods, or phases. Each such discrete unit should correspond to a consideration going the other way. The consideration could be in cash or in kind, but for the purpose of send this should be cryptocurrency (either native/natural or synthetic) that is native to the smart contract technology on which Send is implemented.
        - The sides must choose discrete product or service units to tokenise. For each unit a RT and an OT should be created. One side receives the RT and the other the matching OT. Each pair are inextricably linked.
        - The RT and the OT must also be parametrised, so that they are subject to to the Send basic rules of engagement. By default Send allows the RT to be transferred (assigned) unilaterally by the holding wallet, while the OT requires the transaction to be signed by both wallets (novated) holding the pair.
        - To begin with each RT pair receives the inactive status. This is to signify, when the obligation becomes due. By default, the product/service pair should be activated to initiate the transaction, while the consideration/payment pair should remain inactive. The purpose of this ability is that rudimentary milestones/stages in the contract are supported.
        - During process initiation the parties may connect OT to an oracle that will determine, if the OT has been realised. This is one of the ways in which Send exports complexity to the user layer (or an implmentor for a specific use case or market).
        - The parties might also choose to automate approval of the OT transfer using an API that Send can offer.
        - Finally, a RO pair needs a set of terms and conditions to which the parties have agreed; the contract itself. To this effect the parties submit a hash (Terms NFT) of a document or other object that represents the terms and conditions that bind them. This Terms NFT is held by both parties' wallets and remains in force until all RO pairs are destroyed. To aid interpretation, the contract should explicitly name the endpoints that are tokenised in RO pairs.
        - A contract may be updated by both sides to a new agreement via updating the Terms NFT.
        - The end result of the initiation of a Send agreement is at least the following set:
            - An RO pair representing the Obligation to render a service or product coupled with the Right to receive it.
            - An RO pair representing the Obligation to pay for the rendered service or product and the Right to be paid.
            - The Terms NFT that represents the terms that govern the above RO pairs.
    - Period in force / Performance
        - While the sides of the agreement conduct the transaction the RT/OT pairs can have state to signal the state of the transaction. During this period the parties may assign or novate the contract to transfer Rights or Obligation toeksn any number of times. 
        - Payments sent as part of a Send governend agreement are done via an API that routes them to the RT holder and which can verify when full payment has been made. This is an important feature that lets RT owners sell their receivables and have payments routed directly to the finance provider.
        - Send Rights Tokens may be aggregated and securitized, then sold in aggregate as an investment vehicle with an attacheed cash flow and risk rating. This is one of the key features that make Send applicable to any market, where securitization and/or financing of receivables is desired.
    - Termination
        - There are two ways of satisfying a RO pair. Either the RT is destroyed, or the OT is destroyed. Either way, both tokens are annihilated.
        - Calls to the destroy function of each token in the RT pair may be written up in a smart contract, so that once an obligation is realised its OT destroy function is called. 
        - The most basic kind of automation that should be provided by Send protocol is the consideration (payment), since it can be native to the chain. To realise the consideration the OT holding wallet must transfer a defined token amount to the RT holder by calling the Send Consideration function with the required amount.
- Dispute Resolution
    - Dispute resolution is specific to jurisdictions and to markets, so it is not the goal of Send to enter this space. However, the evidence collected during initiation and performance of a Send governed contract may and should be used in arbitration to help establish facts.
- Conclusion
    - If Send Protocol is implemented as an ERC interface standard, it would allow free composability of receivables, and perhaps even of obligations across a market or even across several markets. Since the Send framework is independent of use case, it should not require adjustments to the protocol to apply it, which means that Send tokens should remain compatible across wallets and other DeFi protocols, yielding a key ingredient of DeFi: composability.
- Consider the following setup for a normal invoiced sale [WiP do not read]
    - Discussion
        - An invoice is a tricky concept, because it isn't a contract in itself and is a document issued usually for tax purposes or to document a payment. It therefore naturally is represented by the receiv
    - Wallets (Identities)
        - Buyer
        - Seller
        - Document content
            - Invoice data object - The object is stored entirely off-chain and is readable to the parties. It may be a PDF with a scan of a physical document and contains sufficient information for the parties to make their decisions.
            - The invoice may contain a link to the contract on which it is based. This contract will also be a document with its own rights tokens.
    - Tokens
        - Receivable - (Rights token)
            - Defined by who receives the payment for the invoice. Through holding the Receivable token, the seller has the right to mark the receivable as completed once the payment has been made. Initially payments may not be made on-chain and so this could be a unilateral operation by the owner or rights to change status can be handled by a payment processor that is trusted by the owner.
            - The Seller may choose to sell the Receivable to another party, in which case they __Send__ the party the invoice and the Receivable token. Legally, this is an __Assignment__.
        - Liability - (Obligation token)
            - The liability is the Buyer's obligation to pay the invoice. The Buyer's liability cannot be unilaterally transferred by the Buyer. It has to be agreed to by the owner of the receivable. Transfer of this token is therefore legally a __Novation__.
        - Document token
            - The invoice 
